<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>èŠå¤©å®¤</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            width: 90%;
            max-width: 800px;
            height: 90vh;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .header .online-count {
            font-size: 14px;
            opacity: 0.9;
        }

        .chat-container {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #f8f9fa;
        }

        .message {
            margin-bottom: 15px;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message-header {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        .username {
            font-weight: bold;
            margin-right: 10px;
        }

        .timestamp {
            font-size: 12px;
            color: #999;
        }

        .message-content {
            background: white;
            padding: 10px 15px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            word-wrap: break-word;
        }



        .message-actions {
            display: flex;
            justify-content: flex-end;
            margin-top: 5px;
        }

        .recall-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            margin-left: 10px;
        }

        .recall-btn:hover {
            background: #c82333;
        }

        .call-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin-left: 10px;
        }

        .call-btn:hover {
            background: #218838;
        }

        .call-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .video-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .video-container.active {
            display: flex;
        }

        .video-content {
            display: flex;
            gap: 20px;
            max-width: 1200px;
            width: 90%;
        }

        .video-box {
            flex: 1;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .video-box video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .video-label {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
        }

        .video-controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }

        .video-control-btn {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .video-control-btn:hover {
            background: rgba(0, 0, 0, 0.9);
        }

        .video-control-btn.end {
            background: #dc3545;
        }

        .video-control-btn.end:hover {
            background: #c82333;
        }

        .call-incoming {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            display: none;
            z-index: 999;
            max-width: 300px;
        }

        .call-incoming.active {
            display: block;
        }

        .call-incoming h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .call-incoming-buttons {
            display: flex;
            gap: 10px;
        }

        .call-incoming-buttons button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .call-accept {
            background: #28a745;
            color: white;
        }

        .call-reject {
            background: #dc3545;
            color: white;
        }

        .system-message {
            text-align: center;
            color: #666;
            font-style: italic;
            margin: 10px 0;
            padding: 5px;
            background: #e9ecef;
            border-radius: 5px;
        }

        .system-message.admin {
            background: #fff3cd;
            color: #856404;
            font-weight: bold;
        }

        .users-panel {
            width: 200px;
            background: #f1f3f5;
            padding: 15px;
            border-left: 1px solid #dee2e6;
            overflow-y: auto;
        }

        .users-panel h3 {
            font-size: 16px;
            margin-bottom: 15px;
            color: #495057;
        }

        .user-item {
            display: flex;
            align-items: center;
            padding: 8px;
            margin-bottom: 8px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .user-actions {
            display: flex;
            gap: 5px;
            margin-left: auto;
        }

        .user-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .user-name {
            font-size: 14px;
            color: #495057;
        }

        .input-area {
            padding: 20px;
            background: white;
            border-top: 1px solid #dee2e6;
        }

        #usernameInput, #roomNameInput, #roomPasswordInput {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #dee2e6;
            border-radius: 25px;
            font-size: 14px;
            outline: none;
            transition: border-color 0.3s;
            margin-bottom: 10px;
        }

        #usernameInput:focus, #roomNameInput:focus, #roomPasswordInput:focus {
            border-color: #667eea;
        }

        #joinBtn {
            width: 100%;
            padding: 12px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 14px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        #joinBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        #chatForm {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        #messageInput {
            flex: 1;
            padding: 12px 15px;
            border: 2px solid #dee2e6;
            border-radius: 25px;
            font-size: 14px;
            outline: none;
            transition: border-color 0.3s;
        }

        #messageInput:focus {
            border-color: #667eea;
        }

        .action-buttons {
            display: flex;
            gap: 8px;
        }

        .action-btn {
            width: 45px;
            height: 45px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.2s;
            background: #f8f9fa;
            color: #667eea;
        }

        .action-btn:hover {
            background: #667eea;
            color: white;
            transform: scale(1.1);
        }

        .action-btn.recording {
            background: #dc3545;
            color: white;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
        }

        #sendBtn {
            padding: 12px 25px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 14px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        #sendBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .hidden {
            display: none !important;
        }



        @media (max-width: 768px) {
            .container {
                width: 100%;
                height: 100vh;
                border-radius: 0;
            }

            .users-panel {
                display: none;
            }

            .chat-container {
                flex-direction: column;
            }

            .messages {
                padding: 15px;
                width: 100%;
            }

            .action-btn {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }

            #chatForm {
                flex-wrap: wrap;
            }

            #messageInput {
                flex-basis: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>èŠå¤©å®¤</h1>
            <div class="online-count">åœ¨çº¿äººæ•°: <span id="userCount">0</span></div>
        </div>

        <div class="chat-container">
            <div class="messages" id="messages">
                <div class="system-message">æ¬¢è¿æ¥åˆ°èŠå¤©å®¤ï¼è¯·è¾“å…¥æ˜µç§°åŠ å…¥ã€‚</div>
            </div>
            <div class="users-panel">
                <h3>åœ¨çº¿ç”¨æˆ·</h3>
                <div id="usersList"></div>
            </div>
        </div>

        <div class="input-area">
            <div id="loginForm">
                <input type="text" id="usernameInput" placeholder="è¯·è¾“å…¥ä½ çš„æ˜µç§°" maxlength="20">
                <button id="joinBtn">åŠ å…¥èŠå¤©</button>
            </div>
            <div id="chatForm" class="hidden">
                <input type="file" id="imageInput" accept="image/*">
                <div class="action-buttons">
                    <button class="action-btn" id="imageBtn" title="å‘é€å›¾ç‰‡">ğŸ“·</button>
                    <button class="action-btn" id="audioBtn" title="å‘é€è¯­éŸ³">ğŸ¤</button>
                    <button class="action-btn" id="videoCallBtn" title="è§†é¢‘é€šè¯">ğŸ“¹</button>
                    <button class="action-btn" id="audioCallBtn" title="è¯­éŸ³é€šè¯">ğŸ“</button>
                </div>
                <input type="text" id="messageInput" placeholder="è¾“å…¥æ¶ˆæ¯..." maxlength="500">
                <button id="sendBtn">å‘é€</button>
            </div>
        </div>
    </div>

    <div class="video-container" id="videoContainer">
        <div class="video-content">
            <div class="video-box">
                <video id="localVideo" autoplay playsinline muted></video>
                <div class="video-label">æˆ‘</div>
            </div>
            <div class="video-box">
                <video id="remoteVideo" autoplay playsinline></video>
                <div class="video-label">å¯¹æ–¹</div>
            </div>
        </div>
        <div class="video-controls">
            <button class="video-control-btn" id="toggleVideoBtn">ğŸ“¹</button>
            <button class="video-control-btn" id="toggleAudioBtn">ğŸ¤</button>
            <button class="video-control-btn end" id="endCallBtn">ğŸ“</button>
        </div>
    </div>

    <div class="call-incoming" id="callIncoming">
        <h3 id="callIncomingText">æ¥ç”µ</h3>
        <div class="call-incoming-buttons">
            <button class="call-accept" onclick="acceptCall()">æ¥å¬</button>
            <button class="call-reject" onclick="rejectCall()">æ‹’ç»</button>
        </div>
    </div>

    <div class="modal" id="deviceSelectModal">
        <div class="modal-content" style="max-width: 500px;">
            <h3>é€‰æ‹©è®¾å¤‡</h3>
            <div id="deviceSelectContent"></div>
            <div class="modal-buttons">
                <button type="button" class="btn btn-cancel" onclick="closeDeviceSelectModal()">å–æ¶ˆ</button>
                <button type="button" class="btn btn-confirm" onclick="confirmDeviceSelect()">ç¡®å®š</button>
            </div>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        let username = '';
        let currentRoom = '';
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let userPermissions = {
            allowAudio: true,
            allowImage: true,
            allowFile: true,
            allowSendMessages: true,
            allowViewMessages: true,
            allowCall: false
        };

        const messagesDiv = document.getElementById('messages');
        const usersListDiv = document.getElementById('usersList');
        const userCountSpan = document.getElementById('userCount');
        const usernameInput = document.getElementById('usernameInput');
        const messageInput = document.getElementById('messageInput');
        const joinBtn = document.getElementById('joinBtn');
        const sendBtn = document.getElementById('sendBtn');
        const loginForm = document.getElementById('loginForm');
        const chatForm = document.getElementById('chatForm');
        const imageInput = document.getElementById('imageInput');
        const imageBtn = document.getElementById('imageBtn');
        const audioBtn = document.getElementById('audioBtn');
        const videoCallBtn = document.getElementById('videoCallBtn');
        const audioCallBtn = document.getElementById('audioCallBtn');
        const videoContainer = document.getElementById('videoContainer');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const toggleVideoBtn = document.getElementById('toggleVideoBtn');
        const toggleAudioBtn = document.getElementById('toggleAudioBtn');
        const endCallBtn = document.getElementById('endCallBtn');
        const callIncoming = document.getElementById('callIncoming');
        const callIncomingText = document.getElementById('callIncomingText');
        const deviceSelectModal = document.getElementById('deviceSelectModal');
        const deviceSelectContent = document.getElementById('deviceSelectContent');

        let localStream = null;
        let remoteStream = null;
        let peerConnection = null;
        let currentCallId = null;
        let isVideoCall = false;
        let isVideoEnabled = true;
        let isAudioEnabled = true;
        
        // è®¾å¤‡é€‰æ‹©ç›¸å…³å˜é‡
        let availableVideoDevices = [];
        let availableAudioDevices = [];
        let selectedVideoDeviceId = null;
        let selectedAudioDeviceId = null;
        let pendingCallAction = null;

        // ä»URLè·¯å¾„è·å–æˆ¿é—´å
        function getRoomFromUrl() {
            const path = window.location.pathname;
            if (path && path !== '/') {
                return path.substring(1); // ç§»é™¤å¼€å¤´çš„æ–œæ 
            }
            return null;
        }

        // å¤„ç†åŠ å…¥æŒ‰é’®ç‚¹å‡»
        joinBtn.addEventListener('click', () => {
            username = usernameInput.value.trim();
            if (username) {
                // ä»URLè·å–æˆ¿é—´åï¼Œé»˜è®¤ä½¿ç”¨'main'
                const roomName = getRoomFromUrl() || 'main';
                
                // å¦‚æœä¸æ˜¯é»˜è®¤æˆ¿é—´ï¼Œæç¤ºç”¨æˆ·è¾“å…¥å¯†ç ï¼ˆå¦‚æœéœ€è¦ï¼‰
                if (roomName !== 'main') {
                    const password = prompt(`è¯·è¾“å…¥æˆ¿é—´ "${roomName}" çš„å¯†ç ï¼ˆç•™ç©ºè¡¨ç¤ºæ— å¯†ç ï¼‰:`);
                    currentRoom = roomName;
                    socket.emit('join', { username, roomName, password: password || null });
                } else {
                    currentRoom = roomName;
                    socket.emit('join', { username, roomName });
                }
            }
        });

        usernameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                joinBtn.click();
            }
        });
        
        // é¡µé¢åŠ è½½æ—¶ä¸éœ€è¦è®¾ç½®è¾“å…¥æ¡†ï¼Œå› ä¸ºå·²ç»åˆ é™¤äº†æˆ¿é—´åè¾“å…¥æ¡†

        sendBtn.addEventListener('click', () => {
            const message = messageInput.value.trim();
            if (message) {
                if (!userPermissions.allowSendMessages) {
                    alert('æ‚¨æ²¡æœ‰å‘é€æ¶ˆæ¯çš„æƒé™');
                    return;
                }
                socket.emit('message', { message, type: 'text' });
                messageInput.value = '';
            }
        });

        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendBtn.click();
            }
        });

        imageBtn.addEventListener('click', () => {
            if (userPermissions.allowImage) {
                imageInput.click();
            } else {
                alert('æ‚¨æ²¡æœ‰å‘é€å›¾ç‰‡çš„æƒé™');
            }
        });

        imageInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                if (!userPermissions.allowImage) {
                    alert('æ‚¨æ²¡æœ‰å‘é€å›¾ç‰‡çš„æƒé™');
                    imageInput.value = '';
                    return;
                }
                try {
                    const reader = new FileReader();
                    reader.onload = async (event) => {
                        const arrayBuffer = event.target.result;
                        const response = await fetch('/upload-image', {
                            method: 'POST',
                            body: arrayBuffer,
                            headers: {
                                'Content-Type': file.type
                            }
                        });
                        const data = await response.json();
                        
                        if (data.imageUrl) {
                            socket.emit('message', { message: data.imageUrl, type: 'image' });
                        }
                    };
                    reader.readAsArrayBuffer(file);
                } catch (error) {
                    console.error('ä¸Šä¼ å›¾ç‰‡å¤±è´¥:', error);
                    alert('ä¸Šä¼ å›¾ç‰‡å¤±è´¥ï¼Œè¯·é‡è¯•');
                }
                
                imageInput.value = '';
            }
        });

        audioBtn.addEventListener('click', async () => {
            if (!userPermissions.allowAudio) {
                alert('æ‚¨æ²¡æœ‰å‘é€è¯­éŸ³çš„æƒé™');
                return;
            }
            
            if (!isRecording) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];
                    
                    mediaRecorder.ondataavailable = (event) => {
                        audioChunks.push(event.data);
                    };
                    
                    mediaRecorder.onstop = async () => {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        
                        try {
                            // ç›´æ¥ä½¿ç”¨Blobä¸Šä¼ ï¼Œä¸è½¬æ¢ä¸ºarrayBuffer
                            const response = await fetch('/upload-audio', {
                                method: 'POST',
                                body: audioBlob,
                                headers: {
                                    'Content-Type': 'audio/webm'
                                }
                            });
                            
                            if (!response.ok) {
                                throw new Error(`ç½‘ç»œå“åº”é”™è¯¯: ${response.statusText}`);
                            }
                            
                            const data = await response.json();
                            
                            if (data.audioUrl) {
                                socket.emit('message', { message: data.audioUrl, type: 'audio' });
                            }
                        } catch (error) {
                            console.error('ä¸Šä¼ è¯­éŸ³å¤±è´¥:', error);
                            alert('ä¸Šä¼ è¯­éŸ³å¤±è´¥ï¼Œè¯·é‡è¯•');
                        }
                        
                        stream.getTracks().forEach(track => track.stop());
                    };
                    
                    mediaRecorder.start();
                    isRecording = true;
                    audioBtn.classList.add('recording');
                    audioBtn.title = 'åœæ­¢å½•åˆ¶';
                } catch (error) {
                    console.error('æ— æ³•è®¿é—®éº¦å…‹é£:', error);
                    alert('æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®');
                }
            } else {
                mediaRecorder.stop();
                isRecording = false;
                audioBtn.classList.remove('recording');
                audioBtn.title = 'å‘é€è¯­éŸ³';
            }
        });

        socket.on('user-joined', (data) => {
            addSystemMessage(`${data.username} åŠ å…¥äº†èŠå¤©å®¤`);
            updateUserList(data.users);
            userCountSpan.textContent = data.userCount;
            
            // æ›´æ–°å½“å‰ç”¨æˆ·çš„æƒé™
            if (data.username === username) {
                const currentUser = data.users.find(u => u.username === username);
                if (currentUser) {
                    userPermissions = currentUser.permissions;
                    // åŠ å…¥æˆ¿é—´æˆåŠŸååˆ‡æ¢åˆ°èŠå¤©ç•Œé¢
                    loginForm.classList.add('hidden');
                    chatForm.classList.remove('hidden');
                    messageInput.focus();
                }
            }
        });
        
        socket.on('user-permissions-changed', (data) => {
            // æ›´æ–°å½“å‰ç”¨æˆ·çš„æƒé™
            const currentUser = data.users.find(u => u.socketId === socket.id);
            if (currentUser) {
                userPermissions = currentUser.permissions;
            }
        });

        socket.on('permission-denied', (data) => {
            alert(data.message);
        });

        socket.on('message', (data) => {
            addMessage(data);
        });

        socket.on('user-left', (data) => {
            addSystemMessage(`${data.username} ç¦»å¼€äº†èŠå¤©å®¤`);
            updateUserList(data.users);
            userCountSpan.textContent = data.userCount;
        });

        socket.on('user-renamed', (data) => {
            addSystemMessage(`${data.oldName} æ”¹åä¸º ${data.newName}`);
            updateUserList(data.users);
            
            // å¦‚æœå½“å‰ç”¨æˆ·è¢«é‡å‘½åï¼Œæ›´æ–°æœ¬åœ°ç”¨æˆ·å
            if (data.oldName === username) {
                username = data.newName;
            }
        });

        socket.on('system-message', (data) => {
            addSystemMessage(data.message, true);
        });

        socket.on('messages-cleared', () => {
            messagesDiv.innerHTML = '<div class="system-message">æ¶ˆæ¯å·²è¢«ç®¡ç†å‘˜æ¸…ç©º</div>';
        });

        socket.on('kicked', (message) => {
            alert(message);
            location.reload();
        });

        socket.on('message-recalled', (messageId) => {
            const messageDiv = document.querySelector(`[data-message-id="${messageId}"]`);
            if (messageDiv) {
                const username = messageDiv.querySelector('.username').textContent;
                messageDiv.innerHTML = `
                    <div class="message-header">
                        <span class="username" style="color: ${messageDiv.querySelector('.username').style.color}">${username}</span>
                        <span class="timestamp">${messageDiv.querySelector('.timestamp').textContent}</span>
                    </div>
                    <div class="message-content">[æ¶ˆæ¯å·²æ’¤å›]</div>
                `;
            }
        });
        
        // æˆ¿é—´åŠ å…¥å¤±è´¥
        socket.on('join-error', (data) => {
            alert(data.message);
        });
        
        // æˆ¿é—´å˜æ›´é€šçŸ¥
        socket.on('room-changed', (data) => {
            currentRoom = data.roomName;
            // æ¸…ç©ºæ¶ˆæ¯åˆ—è¡¨
            messagesDiv.innerHTML = '<div class="system-message">' + data.message + '</div>';
            // æ›´æ–°ç”¨æˆ·åˆ—è¡¨
            updateUserList([]);
        });
        
        // æˆ¿é—´å†å²æ¶ˆæ¯
        socket.on('room-history', (data) => {
            // æ¸…ç©ºå½“å‰æ¶ˆæ¯
            messagesDiv.innerHTML = '';
            // æ·»åŠ å†å²æ¶ˆæ¯
            data.messages.forEach(message => {
                addMessage(message);
            });
        });

        function recallMessage(messageId) {
            socket.emit('message-recall', messageId);
        }

        function addMessage(data) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message';
            messageDiv.dataset.messageId = data.id;
            
            let contentHtml;
            if (data.type === 'image') {
                contentHtml = `<img src="${data.message}" alt="å›¾ç‰‡" style="max-width: 100%; max-height: 200px; border-radius: 5px;">`;
            } else if (data.type === 'audio') {
                contentHtml = `<audio controls style="width: 100%; border-radius: 5px;"><source src="${data.message}" type="audio/webm">æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘æ’­æ”¾</audio>`;
            } else {
                contentHtml = escapeHtml(data.message);
            }
            
            let actionsHtml = '';
            if (data.username === username) {
                actionsHtml = `<div class="message-actions">
                    <button class="recall-btn" onclick="recallMessage('${data.id}')">æ’¤å›</button>
                </div>`;
            }
            
            messageDiv.innerHTML = `
                <div class="message-header">
                    <span class="username" style="color: ${data.color}">${data.username}</span>
                    <span class="timestamp">${data.timestamp}</span>
                </div>
                <div class="message-content">${contentHtml}</div>
                ${actionsHtml}
            `;
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        function addSystemMessage(text, isAdmin = false) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'system-message' + (isAdmin ? ' admin' : '');
            messageDiv.textContent = text;
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        function updateUserList(users) {
            usersListDiv.innerHTML = '';
            users.forEach(user => {
                const userDiv = document.createElement('div');
                userDiv.className = 'user-item';
                
                // åªæœ‰å½“å½“å‰ç”¨æˆ·å’Œç›®æ ‡ç”¨æˆ·éƒ½æœ‰é€šè¯æƒé™æ—¶æ‰æ˜¾ç¤ºé€šè¯æŒ‰é’®
                const showCallButton = userPermissions.allowCall && user.permissions.allowCall;
                
                let callButtonsHtml = '';
                if (showCallButton && user.socketId !== socket.id) {
                    callButtonsHtml = `
                        <div class="user-actions">
                            <button class="call-btn" onclick="startVideoCall('${user.socketId}', '${user.username}')">ğŸ“¹</button>
                            <button class="call-btn" onclick="startAudioCall('${user.socketId}', '${user.username}')">ğŸ“</button>
                        </div>
                    `;
                }
                
                userDiv.innerHTML = `
                    <div class="user-color" style="background: ${user.color}"></div>
                    <div class="user-name">${escapeHtml(user.username)}</div>
                    ${callButtonsHtml}
                `;
                
                usersListDiv.appendChild(userDiv);
            });
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // åª’ä½“å½•åˆ¶å™¨
        mediaRecorder = null;
        let mediaChunks = [];
        isRecording = false;
        let isDeviceSelectModalOpen = false;
        
        // åª’ä½“æºå’Œç¼“å†²åŒº
        let mediaSource = null;
        let sourceBuffer = null;
        let audioContext = null;
        let audioSource = null;
        let audioBuffer = null;
        
        // å½“å‰åª’ä½“URL
        let currentMediaUrl = null;
        
        // åª’ä½“æ•°æ®é˜Ÿåˆ—
        let mediaDataQueue = [];

        // å¼€å§‹è§†é¢‘é€šè¯
        async function startVideoCall(targetSocketId, targetUsername) {
            if (!userPermissions.allowCall) {
                alert('æ‚¨æ²¡æœ‰é€šè¯æƒé™');
                return;
            }
            
            isVideoCall = true;
            currentCallId = Date.now().toString();
            currentTargetSocketId = targetSocketId;
            
            try {
                // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒåª’ä½“è®¾å¤‡è®¿é—®');
                }
                
                // è·å–å¯ç”¨è®¾å¤‡
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                const audioDevices = devices.filter(device => device.kind === 'audioinput');
                
                console.log('å¯ç”¨è§†é¢‘è®¾å¤‡:', videoDevices);
                console.log('å¯ç”¨éŸ³é¢‘è®¾å¤‡:', audioDevices);
                
                if (videoDevices.length === 0) {
                    throw new Error('æœªæ£€æµ‹åˆ°æ‘„åƒå¤´è®¾å¤‡');
                }
                
                if (audioDevices.length === 0) {
                    throw new Error('æœªæ£€æµ‹åˆ°éº¦å…‹é£è®¾å¤‡');
                }
                
                // å¦‚æœæœ‰å¤šä¸ªè®¾å¤‡ï¼Œæ˜¾ç¤ºè®¾å¤‡é€‰æ‹©ç•Œé¢
                if (videoDevices.length > 1 || audioDevices.length > 1) {
                    availableVideoDevices = videoDevices;
                    availableAudioDevices = audioDevices;
                    selectedVideoDeviceId = videoDevices[0].deviceId;
                    selectedAudioDeviceId = audioDevices[0].deviceId;
                    pendingCallAction = { type: 'video', targetSocketId, targetUsername };
                    showDeviceSelectModal();
                    return;
                }
                
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true
                    },
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: 'user'
                    }
                });
                
                localStream = stream;
                localVideo.srcObject = stream;
                
                // ä¸è¦ç«‹å³å¼€å§‹å½•åˆ¶ï¼Œç­‰å¾…å¯¹æ–¹æ¥å—é€šè¯åå†å¼€å§‹
                // startMediaRecording(stream);
                
                socket.emit('call-request', {
                    targetSocketId: targetSocketId,
                    callId: currentCallId,
                    type: 'video',
                    fromUsername: username
                });
                
                videoContainer.classList.add('active');
                addSystemMessage(`æ­£åœ¨å‘ ${targetUsername} å‘èµ·è§†é¢‘é€šè¯...`);
            } catch (error) {
                console.error('è·å–æ‘„åƒå¤´å¤±è´¥:', error);
                let errorMessage = 'æ— æ³•è®¿é—®æ‘„åƒå¤´ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®';
                
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    errorMessage = 'æ‚¨æ‹’ç»äº†æ‘„åƒå¤´å’Œéº¦å…‹é£æƒé™ï¼Œè¯·åœ¨æµè§ˆå™¨è®¾ç½®ä¸­å…è®¸è®¿é—®';
                } else if (error.name === 'NotFoundError') {
                    errorMessage = 'æœªæ‰¾åˆ°æ‘„åƒå¤´æˆ–éº¦å…‹é£è®¾å¤‡';
                } else if (error.name === 'NotReadableError') {
                    errorMessage = 'æ— æ³•è¯»å–æ‘„åƒå¤´æˆ–éº¦å…‹é£æ•°æ®';
                } else if (error.message) {
                    errorMessage = error.message;
                }
                
                alert(errorMessage);
            }
        }

        // å¼€å§‹è¯­éŸ³é€šè¯
        async function startAudioCall(targetSocketId, targetUsername) {
            if (!userPermissions.allowCall) {
                alert('æ‚¨æ²¡æœ‰é€šè¯æƒé™');
                return;
            }
            
            isVideoCall = false;
            currentCallId = Date.now().toString();
            currentTargetSocketId = targetSocketId;
            
            try {
                // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒåª’ä½“è®¾å¤‡è®¿é—®');
                }
                
                // è·å–å¯ç”¨è®¾å¤‡
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioDevices = devices.filter(device => device.kind === 'audioinput');
                
                console.log('å¯ç”¨éŸ³é¢‘è®¾å¤‡:', audioDevices);
                
                if (audioDevices.length === 0) {
                    throw new Error('æœªæ£€æµ‹åˆ°éº¦å…‹é£è®¾å¤‡');
                }
                
                // å¦‚æœæœ‰å¤šä¸ªè®¾å¤‡ï¼Œæ˜¾ç¤ºè®¾å¤‡é€‰æ‹©ç•Œé¢
                if (audioDevices.length > 1) {
                    availableVideoDevices = [];
                    availableAudioDevices = audioDevices;
                    selectedVideoDeviceId = null;
                    selectedAudioDeviceId = audioDevices[0].deviceId;
                    pendingCallAction = { type: 'audio', targetSocketId, targetUsername };
                    showDeviceSelectModal();
                    return;
                }
                
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true
                    }
                });
                
                localStream = stream;
                
                // ä¸è¦ç«‹å³å¼€å§‹å½•åˆ¶ï¼Œç­‰å¾…å¯¹æ–¹æ¥å—é€šè¯åå†å¼€å§‹
                // startMediaRecording(stream);
                
                socket.emit('call-request', {
                    targetSocketId: targetSocketId,
                    callId: currentCallId,
                    type: 'audio',
                    fromUsername: username
                });
                
                videoContainer.classList.add('active');
                addSystemMessage(`æ­£åœ¨å‘ ${targetUsername} å‘èµ·è¯­éŸ³é€šè¯...`);
            } catch (error) {
                console.error('è·å–éº¦å…‹é£å¤±è´¥:', error);
                let errorMessage = 'æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®';
                
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    errorMessage = 'æ‚¨æ‹’ç»äº†éº¦å…‹é£æƒé™ï¼Œè¯·åœ¨æµè§ˆå™¨è®¾ç½®ä¸­å…è®¸è®¿é—®';
                } else if (error.name === 'NotFoundError') {
                    errorMessage = 'æœªæ‰¾åˆ°éº¦å…‹é£è®¾å¤‡';
                } else if (error.name === 'NotReadableError') {
                    errorMessage = 'æ— æ³•è¯»å–éº¦å…‹é£æ•°æ®';
                } else if (error.message) {
                    errorMessage = error.message;
                }
                
                alert(errorMessage);
            }
        }

        // å¼€å§‹åª’ä½“å½•åˆ¶
        function startMediaRecording(stream) {
            mediaChunks = [];
            
            const mimeType = isVideoCall ? 'video/webm;codecs=vp8' : 'audio/webm';
            mediaRecorder = new MediaRecorder(stream, { 
                mimeType,
                videoBitsPerSecond: isVideoCall ? 100000 : undefined
            });
            
            mediaRecorder.ondataavailable = async (event) => {
                if (event.data && event.data.size > 0) {
                    try {
                        // å°†Blobè½¬æ¢ä¸ºUint8Array
                        const arrayBuffer = await event.data.arrayBuffer();
                        const uint8Array = new Uint8Array(arrayBuffer);
                        
                        // é€šè¿‡Socket.ioå‘é€åª’ä½“æ•°æ®
                        socket.emit('call-media', {
                            targetSocketId: currentTargetSocketId,
                            callId: currentCallId,
                            type: isVideoCall ? 'video' : 'audio',
                            data: uint8Array
                        });
                    } catch (error) {
                        console.error('å‘é€åª’ä½“æ•°æ®å¤±è´¥:', error);
                    }
                }
            };
            
            mediaRecorder.start(500); // æ¯500mså‘é€ä¸€æ¬¡æ•°æ®
            isRecording = true;
        }

        // åœæ­¢åª’ä½“å½•åˆ¶
        function stopMediaRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
            }
        }

        // æ¥å—é€šè¯
        async function acceptCall() {
            callIncoming.classList.remove('active');
            
            try {
                // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒåª’ä½“è®¾å¤‡è®¿é—®');
                }
                
                // è·å–å¯ç”¨è®¾å¤‡
                const devices = await navigator.mediaDevices.enumerateDevices();
                
                if (isVideoCall) {
                    const videoDevices = devices.filter(device => device.kind === 'videoinput');
                    const audioDevices = devices.filter(device => device.kind === 'audioinput');
                    
                    console.log('å¯ç”¨è§†é¢‘è®¾å¤‡:', videoDevices);
                    console.log('å¯ç”¨éŸ³é¢‘è®¾å¤‡:', audioDevices);
                    
                    if (videoDevices.length === 0) {
                        throw new Error('æœªæ£€æµ‹åˆ°æ‘„åƒå¤´è®¾å¤‡');
                    }
                    
                    if (audioDevices.length === 0) {
                        throw new Error('æœªæ£€æµ‹åˆ°éº¦å…‹é£è®¾å¤‡');
                    }
                    
                    // å¦‚æœæœ‰å¤šä¸ªè®¾å¤‡ï¼Œæ˜¾ç¤ºè®¾å¤‡é€‰æ‹©ç•Œé¢
                    if (videoDevices.length > 1 || audioDevices.length > 1) {
                        availableVideoDevices = videoDevices;
                        availableAudioDevices = audioDevices;
                        selectedVideoDeviceId = videoDevices[0].deviceId;
                        selectedAudioDeviceId = audioDevices[0].deviceId;
                        // è®¾ç½®pendingCallActionï¼Œç”¨äºè®¾å¤‡é€‰æ‹©åçš„é€šè¯æµç¨‹
                        pendingCallAction = { 
                            type: 'video', 
                            isAcceptingCall: true,
                            targetSocketId: currentCallerSocketId,
                            targetUsername: 'å¯¹æ–¹'
                        };
                        showDeviceSelectModal();
                        return;
                    }
                    
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true
                        },
                        video: {
                            width: { ideal: 640 },
                            height: { ideal: 480 },
                            facingMode: 'user'
                        }
                    });
                    
                    localStream = stream;
                    localVideo.srcObject = stream;
                    
                    // æ¥å—é€šè¯æ—¶ç«‹å³å¼€å§‹å½•åˆ¶å¹¶å‘é€æ•°æ®
                    startMediaRecording(stream);
                    
                    // è®¾ç½®ç›®æ ‡Socket IDï¼Œç¡®ä¿èƒ½å‘é€æ•°æ®ç»™å¯¹æ–¹
                    currentTargetSocketId = currentCallerSocketId;
                    
                    socket.emit('call-accept', {
                        callerSocketId: currentCallerSocketId,
                        callId: currentCallId
                    });
                    
                    videoContainer.classList.add('active');
                    addSystemMessage('é€šè¯å·²æ¥é€š');
                } else {
                    const audioDevices = devices.filter(device => device.kind === 'audioinput');
                    
                    console.log('å¯ç”¨éŸ³é¢‘è®¾å¤‡:', audioDevices);
                    
                    if (audioDevices.length === 0) {
                        throw new Error('æœªæ£€æµ‹åˆ°éº¦å…‹é£è®¾å¤‡');
                    }
                    
                    // å¦‚æœæœ‰å¤šä¸ªè®¾å¤‡ï¼Œæ˜¾ç¤ºè®¾å¤‡é€‰æ‹©ç•Œé¢
                    if (audioDevices.length > 1) {
                        availableVideoDevices = [];
                        availableAudioDevices = audioDevices;
                        selectedVideoDeviceId = null;
                        selectedAudioDeviceId = audioDevices[0].deviceId;
                        // è®¾ç½®pendingCallActionï¼Œç”¨äºè®¾å¤‡é€‰æ‹©åçš„é€šè¯æµç¨‹
                        pendingCallAction = { 
                            type: 'audio', 
                            isAcceptingCall: true,
                            targetSocketId: currentCallerSocketId,
                            targetUsername: 'å¯¹æ–¹'
                        };
                        showDeviceSelectModal();
                        return;
                    }
                    
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true
                        }
                    });
                    
                    localStream = stream;
                    
                    // ä¸è¦ç«‹å³å¼€å§‹å½•åˆ¶ï¼Œç­‰å¾…å¯¹æ–¹æ¥å—é€šè¯åå†å¼€å§‹
                    // startMediaRecording(stream);
                    
                    // è®¾ç½®ç›®æ ‡Socket IDï¼Œç¡®ä¿èƒ½å‘é€æ•°æ®ç»™å¯¹æ–¹
                    currentTargetSocketId = currentCallerSocketId;
                    
                    socket.emit('call-accept', {
                        callerSocketId: currentCallerSocketId,
                        callId: currentCallId
                    });
                    
                    videoContainer.classList.add('active');
                    addSystemMessage('é€šè¯å·²æ¥é€š');
                }
            } catch (error) {
                console.error('è·å–åª’ä½“æµå¤±è´¥:', error);
                let errorMessage = 'æ— æ³•è®¿é—®æ‘„åƒå¤´/éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®';
                
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    errorMessage = 'æ‚¨æ‹’ç»äº†æ‘„åƒå¤´å’Œéº¦å…‹é£æƒé™ï¼Œè¯·åœ¨æµè§ˆå™¨è®¾ç½®ä¸­å…è®¸è®¿é—®';
                } else if (error.name === 'NotFoundError') {
                    errorMessage = 'æœªæ‰¾åˆ°æ‘„åƒå¤´æˆ–éº¦å…‹é£è®¾å¤‡';
                } else if (error.name === 'NotReadableError') {
                    errorMessage = 'æ— æ³•è¯»å–æ‘„åƒå¤´æˆ–éº¦å…‹é£æ•°æ®';
                } else if (error.message) {
                    errorMessage = error.message;
                }
                
                alert(errorMessage);
                // é‡ç½®æ¥ç”µçŠ¶æ€
                callIncoming.classList.remove('active');
                currentCallId = null;
            }
        }

        // æ‹’ç»é€šè¯
        function rejectCall() {
            callIncoming.classList.remove('active');
            
                socket.emit('call-media', {
                    targetSocketId: currentCallerSocketId,
                    callId: currentCallId,
                    type: 'reject'
                });
                
                addSystemMessage('å·²æ‹’ç»é€šè¯');
                currentCallId = null;
            }   
        

        // ç»“æŸé€šè¯
        function endCall() {
            stopMediaRecording();
            
            // æ¸…ç†åª’ä½“URL
            if (currentMediaUrl) {
                URL.revokeObjectURL(currentMediaUrl);
                currentMediaUrl = null;
            }
            
            // æ¸…ç†åª’ä½“æºå’ŒéŸ³é¢‘ä¸Šä¸‹æ–‡
            if (mediaSource) {
                mediaSource.endOfStream();
                remoteVideo.srcObject = null;
                mediaSource = null;
            }
            
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            
            videoContainer.classList.remove('active');
            
            if (currentTargetSocketId) {
                socket.emit('call-end', {
                    targetSocketId: currentTargetSocketId,
                    callId: currentCallId
                });
            }
            
            currentCallId = null;
            currentTargetSocketId = null;
            sourceBuffer = [];
            audioBuffer = [];
            mediaDataQueue = [];
            addSystemMessage('é€šè¯å·²ç»“æŸ');
        }

        // åˆ‡æ¢è§†é¢‘
        function toggleVideo() {
            if (localStream) {
                const videoTrack = localStream.getVideoTracks()[0];
                if (videoTrack) {
                    isVideoEnabled = !isVideoEnabled;
                    videoTrack.enabled = isVideoEnabled;
                    toggleVideoBtn.textContent = isVideoEnabled ? 'ğŸ“¹' : 'ğŸš«';
                }
            }
        }

        // åˆ‡æ¢éŸ³é¢‘
        function toggleAudio() {
            if (localStream) {
                const audioTrack = localStream.getAudioTracks()[0];
                if (audioTrack) {
                    isAudioEnabled = !isAudioEnabled;
                    audioTrack.enabled = isAudioEnabled;
                    toggleAudioBtn.textContent = isAudioEnabled ? 'ğŸ¤' : 'ğŸ”‡';
                }
            }
        }

        // Socketäº‹ä»¶å¤„ç†
        let currentCallerSocketId = null;
        let currentTargetSocketId = null;
        let remoteVideoBuffer = [];

        // æ¥æ”¶é€šè¯è¯·æ±‚
        socket.on('call-request', (data) => {
            if (!userPermissions.allowCall) {
                socket.emit('call-reject', {
                    callerSocketId: data.from,
                    callId: data.callId
                });
                return;
            }
            
            currentCallerSocketId = data.from;
            currentCallId = data.callId;
            // ä»è¯·æ±‚æ•°æ®ä¸­è·å–é€šè¯ç±»å‹
            isVideoCall = data.type === 'video';
            
            callIncomingText.textContent = `${data.fromUsername} è¯·æ±‚${isVideoCall ? 'è§†é¢‘' : 'è¯­éŸ³'}é€šè¯`;
            callIncoming.classList.add('active');
        });

        // é€šè¯è¢«æ¥å—
        socket.on('call-accepted', (data) => {
            addSystemMessage('å¯¹æ–¹å·²æ¥å—é€šè¯');
            // å¯¹æ–¹æ¥å—é€šè¯åï¼Œå¼€å§‹å‘é€åª’ä½“æ•°æ®
            if (localStream && !isRecording) {
                startMediaRecording(localStream);
            }
        });

        // é€šè¯è¢«æ‹’ç»
        socket.on('call-rejected', (data) => {
            stopMediaRecording();
            addSystemMessage('å¯¹æ–¹æ‹’ç»äº†é€šè¯');
            currentCallId = null;
        });

        // é€šè¯ç»“æŸ
        socket.on('call-ended', (data) => {
            stopMediaRecording();
            videoContainer.classList.remove('active');
            currentCallId = null;
            addSystemMessage('é€šè¯å·²ç»“æŸ');
        });

        // æ¥æ”¶åª’ä½“æ•°æ®
        socket.on('call-media', (data) => {
            if (data.callId === currentCallId) {
                try {
                    // å°†Uint8Arrayè½¬æ¢å›Blob
                    const uint8Array = new Uint8Array(data.data);
                    const blob = new Blob([uint8Array], { type: isVideoCall ? 'video/webm' : 'audio/webm' });
                    
                    if (isVideoCall) {
                        // è§†é¢‘æ’­æ”¾ - æ¯æ¬¡æ›´æ–°URL
                        const url = URL.createObjectURL(blob);
                        if (currentMediaUrl) {
                            URL.revokeObjectURL(currentMediaUrl);
                        }
                        currentMediaUrl = url;
                        remoteVideo.src = url;
                    } else {
                        // éŸ³é¢‘æ’­æ”¾ - æ¯æ¬¡æ›´æ–°URL
                        const url = URL.createObjectURL(blob);
                        if (currentMediaUrl) {
                            URL.revokeObjectURL(currentMediaUrl);
                        }
                        currentMediaUrl = url;
                        
                        // åˆ›å»ºæ–°çš„éŸ³é¢‘å…ƒç´ å¹¶æ’­æ”¾
                        const audio = new Audio(url);
                        audio.play();
                    }
                } catch (error) {
                    console.error('æ’­æ”¾åª’ä½“æ•°æ®å¤±è´¥:', error);
                }
            }
        });

        // è§†é¢‘é€šè¯æŒ‰é’®äº‹ä»¶
        videoCallBtn.addEventListener('click', () => {
            const targetUser = prompt('è¯·è¾“å…¥è¦è§†é¢‘é€šè¯çš„ç”¨æˆ·å:');
            if (targetUser) {
                const userElements = usersListDiv.querySelectorAll('.user-item');
                for (let userElement of userElements) {
                    const name = userElement.querySelector('.user-name').textContent;
                    if (name === targetUser) {
                        const callBtn = userElement.querySelector('.call-btn');
                        if (callBtn && callBtn.textContent === 'ğŸ“¹') {
                            const socketId = callBtn.getAttribute('onclick').match(/'([^']+)'/)[1];
                            startVideoCall(socketId, targetUser);
                            return;
                        }
                    }
                }
                alert('æœªæ‰¾åˆ°è¯¥ç”¨æˆ·æˆ–è¯¥ç”¨æˆ·æ²¡æœ‰é€šè¯æƒé™');
            }
        });

        // è¯­éŸ³é€šè¯æŒ‰é’®äº‹ä»¶
        audioCallBtn.addEventListener('click', () => {
            const targetUser = prompt('è¯·è¾“å…¥è¦è¯­éŸ³é€šè¯çš„ç”¨æˆ·å:');
            if (targetUser) {
                const userElements = usersListDiv.querySelectorAll('.user-item');
                for (let userElement of userElements) {
                    const name = userElement.querySelector('.user-name').textContent;
                    if (name === targetUser) {
                        const callBtns = userElement.querySelectorAll('.call-btn');
                        for (let callBtn of callBtns) {
                            if (callBtn.textContent === 'ğŸ“') {
                                const socketId = callBtn.getAttribute('onclick').match(/'([^']+)'/)[1];
                                startAudioCall(socketId, targetUser);
                                return;
                            }
                        }
                    }
                }
                alert('æœªæ‰¾åˆ°è¯¥ç”¨æˆ·æˆ–è¯¥ç”¨æˆ·æ²¡æœ‰é€šè¯æƒé™');
            }
        });

        // è§†é¢‘æ§åˆ¶æŒ‰é’®äº‹ä»¶
        toggleVideoBtn.addEventListener('click', toggleVideo);
        toggleAudioBtn.addEventListener('click', toggleAudio);
        endCallBtn.addEventListener('click', endCall);
        
        // æ˜¾ç¤ºè®¾å¤‡é€‰æ‹©æ¨¡æ€æ¡†
        function showDeviceSelectModal() {
            // å¦‚æœæ¨¡æ€æ¡†å·²ç»æ‰“å¼€ï¼Œä¸é‡å¤æ˜¾ç¤º
            if (isDeviceSelectModalOpen) {
                return;
            }
            
            isDeviceSelectModalOpen = true;
            deviceSelectContent.innerHTML = '';
            
            // æ·»åŠ æœç´¢æ¡†
            const searchInput = document.createElement('input');
            searchInput.type = 'text';
            searchInput.placeholder = 'æœç´¢è®¾å¤‡...';
            searchInput.style.width = '100%';
            searchInput.style.padding = '10px';
            searchInput.style.marginBottom = '15px';
            searchInput.style.border = '1px solid #dee2e6';
            searchInput.style.borderRadius = '5px';
            searchInput.addEventListener('input', (e) => {
                filterDeviceList(e.target.value);
            });
            
            deviceSelectContent.appendChild(searchInput);
            
            // æ·»åŠ è§†é¢‘è®¾å¤‡é€‰æ‹©
            if (availableVideoDevices.length > 0) {
                const videoSection = document.createElement('div');
                videoSection.innerHTML = '<h4 style="margin-bottom: 10px;">é€‰æ‹©æ‘„åƒå¤´:</h4>';
                
                availableVideoDevices.forEach((device, index) => {
                    const deviceDiv = document.createElement('div');
                    deviceDiv.style.display = 'flex';
                    deviceDiv.style.alignItems = 'center';
                    deviceDiv.style.padding = '10px';
                    deviceDiv.style.marginBottom = '5px';
                    deviceDiv.style.border = '1px solid #e9ecef';
                    deviceDiv.style.borderRadius = '5px';
                    deviceDiv.style.cursor = 'pointer';
                    deviceDiv.dataset.deviceId = device.deviceId;
                    deviceDiv.dataset.deviceType = 'video';
                    
                    const deviceLabel = device.label || `æ‘„åƒå¤´ ${index + 1}`;
                    
                    deviceDiv.innerHTML = `
                        <input type="radio" name="videoDevice" value="${device.deviceId}" ${device.deviceId === selectedVideoDeviceId ? 'checked' : ''}>
                        <span style="margin-left: 10px;">${escapeHtml(deviceLabel)}</span>
                    `;
                    
                    deviceDiv.addEventListener('click', () => {
                        selectedVideoDeviceId = device.deviceId;
                        document.querySelectorAll('input[name="videoDevice"]').forEach(input => {
                            input.checked = input.value === device.deviceId;
                        });
                    });
                    
                    videoSection.appendChild(deviceDiv);
                });
                
                deviceSelectContent.appendChild(videoSection);
            }
            
            // æ·»åŠ éŸ³é¢‘è®¾å¤‡é€‰æ‹©
            if (availableAudioDevices.length > 0) {
                const audioSection = document.createElement('div');
                audioSection.innerHTML = '<h4 style="margin-bottom: 10px;">é€‰æ‹©éº¦å…‹é£:</h4>';
                
                availableAudioDevices.forEach((device, index) => {
                    const deviceDiv = document.createElement('div');
                    deviceDiv.style.display = 'flex';
                    deviceDiv.style.alignItems = 'center';
                    deviceDiv.style.padding = '10px';
                    deviceDiv.style.marginBottom = '5px';
                    deviceDiv.style.border = '1px solid #e9ecef';
                    deviceDiv.style.borderRadius = '5px';
                    deviceDiv.style.cursor = 'pointer';
                    deviceDiv.dataset.deviceId = device.deviceId;
                    deviceDiv.dataset.deviceType = 'audio';
                    
                    const deviceLabel = device.label || `éº¦å…‹é£ ${index + 1}`;
                    
                    deviceDiv.innerHTML = `
                        <input type="radio" name="audioDevice" value="${device.deviceId}" ${device.deviceId === selectedAudioDeviceId ? 'checked' : ''}>
                        <span style="margin-left: 10px;">${escapeHtml(deviceLabel)}</span>
                    `;
                    
                    deviceDiv.addEventListener('click', () => {
                        selectedAudioDeviceId = device.deviceId;
                        document.querySelectorAll('input[name="audioDevice"]').forEach(input => {
                            input.checked = input.value === device.deviceId;
                        });
                    });
                    
                    audioSection.appendChild(deviceDiv);
                });
                
                deviceSelectContent.appendChild(audioSection);
            }
            
            deviceSelectModal.classList.add('active');
        }
        
        // è¿‡æ»¤è®¾å¤‡åˆ—è¡¨
        function filterDeviceList(searchTerm) {
            const deviceDivs = deviceSelectContent.querySelectorAll('[data-device-type]');
            
            deviceDivs.forEach(deviceDiv => {
                const deviceName = deviceDiv.querySelector('span').textContent.toLowerCase();
                const isVisible = deviceName.includes(searchTerm.toLowerCase());
                deviceDiv.style.display = isVisible ? 'flex' : 'none';
            });
        }
        
        // å…³é—­è®¾å¤‡é€‰æ‹©æ¨¡æ€æ¡†
        function closeDeviceSelectModal() {
            deviceSelectModal.classList.remove('active');
            isDeviceSelectModalOpen = false;
            pendingCallAction = null;
        }
        
        // ç¡®è®¤è®¾å¤‡é€‰æ‹©
        function confirmDeviceSelect() {
            if (pendingCallAction) {
                deviceSelectModal.classList.remove('active');
                isDeviceSelectModalOpen = false;
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯æ¥å—é€šè¯çš„æƒ…å†µ
                if (pendingCallAction.isAcceptingCall) {
                    // ä½¿ç”¨é€‰æ‹©çš„è®¾å¤‡æ¥å—é€šè¯
                    if (pendingCallAction.type === 'video') {
                        acceptVideoCallWithDevice(selectedVideoDeviceId, selectedAudioDeviceId);
                    } else if (pendingCallAction.type === 'audio') {
                        acceptAudioCallWithDevice(selectedAudioDeviceId);
                    }
                } else {
                    // ä½¿ç”¨é€‰æ‹©çš„è®¾å¤‡å‘èµ·é€šè¯
                    if (pendingCallAction.type === 'video') {
                        startVideoCallWithDevice(pendingCallAction.targetSocketId, pendingCallAction.targetUsername, selectedVideoDeviceId);
                    } else if (pendingCallAction.type === 'audio') {
                        startAudioCallWithDevice(pendingCallAction.targetSocketId, pendingCallAction.targetUsername, selectedAudioDeviceId);
                    }
                }
            }
        }
        
        // ä½¿ç”¨æŒ‡å®šè®¾å¤‡æ¥å—è§†é¢‘é€šè¯
        async function acceptVideoCallWithDevice(videoDeviceId, audioDeviceId) {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        deviceId: audioDeviceId,
                        echoCancellation: true,
                        noiseSuppression: true
                    },
                    video: {
                        deviceId: videoDeviceId,
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: 'user'
                    }
                });
                
                localStream = stream;
                localVideo.srcObject = stream;
                
                // æ¥å—é€šè¯æ—¶ç«‹å³å¼€å§‹å½•åˆ¶å¹¶å‘é€æ•°æ®
                startMediaRecording(stream);
                
                // è®¾ç½®ç›®æ ‡Socket IDï¼Œç¡®ä¿èƒ½å‘é€æ•°æ®ç»™å¯¹æ–¹
                currentTargetSocketId = currentCallerSocketId;
                
                socket.emit('call-accept', {
                    callerSocketId: currentCallerSocketId,
                    callId: currentCallId
                });
                
                videoContainer.classList.add('active');
                addSystemMessage('é€šè¯å·²æ¥é€š');
            } catch (error) {
                console.error('è·å–åª’ä½“æµå¤±è´¥:', error);
                alert('æ— æ³•è®¿é—®æ‘„åƒå¤´/éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®');
            }
        }
        
        // ä½¿ç”¨æŒ‡å®šè®¾å¤‡æ¥å—è¯­éŸ³é€šè¯
        async function acceptAudioCallWithDevice(audioDeviceId) {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        deviceId: audioDeviceId,
                        echoCancellation: true,
                        noiseSuppression: true
                    }
                });
                
                localStream = stream;
                
                // ä¸è¦ç«‹å³å¼€å§‹å½•åˆ¶ï¼Œç­‰å¾…å¯¹æ–¹æ¥å—é€šè¯åå†å¼€å§‹
                // startMediaRecording(stream);
                
                // è®¾ç½®ç›®æ ‡Socket IDï¼Œç¡®ä¿èƒ½å‘é€æ•°æ®ç»™å¯¹æ–¹
                currentTargetSocketId = currentCallerSocketId;
                
                socket.emit('call-accept', {
                    callerSocketId: currentCallerSocketId,
                    callId: currentCallId
                });
                
                videoContainer.classList.add('active');
                addSystemMessage('é€šè¯å·²æ¥é€š');
            } catch (error) {
                console.error('è·å–åª’ä½“æµå¤±è´¥:', error);
                alert('æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®');
            }
        }
        
        // ä½¿ç”¨æŒ‡å®šè®¾å¤‡å¼€å§‹è§†é¢‘é€šè¯
        async function startVideoCallWithDevice(targetSocketId, targetUsername, deviceId) {
            if (!userPermissions.allowCall) {
                alert('æ‚¨æ²¡æœ‰é€šè¯æƒé™');
                return;
            }
            
            isVideoCall = true;
            currentCallId = Date.now().toString();
            currentTargetSocketId = targetSocketId;
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        deviceId: selectedAudioDeviceId,
                        echoCancellation: true,
                        noiseSuppression: true
                    },
                    video: {
                        deviceId: deviceId,
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: 'user'
                    }
                });
                
                localStream = stream;
                localVideo.srcObject = stream;
                
                // ä¸è¦ç«‹å³å¼€å§‹å½•åˆ¶ï¼Œç­‰å¾…å¯¹æ–¹æ¥å—é€šè¯åå†å¼€å§‹
                // startMediaRecording(stream);
                
                socket.emit('call-request', {
                    targetSocketId: targetSocketId,
                    callId: currentCallId,
                    type: 'video',
                    fromUsername: username
                });
                
                videoContainer.classList.add('active');
                addSystemMessage(`æ­£åœ¨å‘ ${targetUsername} å‘èµ·è§†é¢‘é€šè¯...`);
            } catch (error) {
                console.error('è·å–æ‘„åƒå¤´å¤±è´¥:', error);
                alert('æ— æ³•è®¿é—®æ‘„åƒå¤´ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®');
            }
        }
        
        // ä½¿ç”¨æŒ‡å®šè®¾å¤‡å¼€å§‹è¯­éŸ³é€šè¯
        async function startAudioCallWithDevice(targetSocketId, targetUsername, deviceId) {
            if (!userPermissions.allowCall) {
                alert('æ‚¨æ²¡æœ‰é€šè¯æƒé™');
                return;
            }
            
            isVideoCall = false;
            currentCallId = Date.now().toString();
            currentTargetSocketId = targetSocketId;
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        deviceId: deviceId,
                        echoCancellation: true,
                        noiseSuppression: true
                    }
                });
                
                localStream = stream;
                
                // ä¸è¦ç«‹å³å¼€å§‹å½•åˆ¶ï¼Œç­‰å¾…å¯¹æ–¹æ¥å—é€šè¯åå†å¼€å§‹
                // startMediaRecording(stream);
                
                socket.emit('call-request', {
                    targetSocketId: targetSocketId,
                    callId: currentCallId,
                    type: 'audio',
                    fromUsername: username
                });
                
                videoContainer.classList.add('active');
                addSystemMessage(`æ­£åœ¨å‘ ${targetUsername} å‘èµ·è¯­éŸ³é€šè¯...`);
            } catch (error) {
                console.error('è·å–éº¦å…‹é£å¤±è´¥:', error);
                alert('æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®');
            }
        }
    </script>
</body>
</html>
